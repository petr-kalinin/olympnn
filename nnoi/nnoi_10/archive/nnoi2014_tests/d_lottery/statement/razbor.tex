\input{lottery.tex}

\solution
Чтобы решить данную задачу, необходимо было догадаться до простой идеи, что чтобы
максимизировать выигрыш, необходимо подделать сертификаты таким образом, чтобы
<<окружить>> блоки из подряд идущих номеров билетов, для которых были куплены сертификаты.
Т.е. для каждого купленного сертификата требуется подделать сертификат на билет с
номером на 1 больше и на 1 меньше, если только сертификат на такой билет ещё не был куплен.
Докажем данный факт.

Пусть для некоторого билета с номером $i$ был куплен сертификат,
а для одного из соседних (для определённости пусть это будет билет с номером $i+1$)
сертификат не был куплен и злоумышленник сертификат для него не подделал.
В этом случае, если в ходе проведения лотереи выпало число $i+1$, то злоумышленник
вообще ничего не получит (если не был подделан сертификат для билета с номером $i+2$,
или билета с таким номером не существует), либо поделит приз с обладателем билета
$i$ (если был подделан сертификат для билета с номером $i+2$). Таким образом, доказана
необходимость подделывать сертификаты для всех билетов, соседних с теми, для которых
сертификаты были куплены.

Покажем, что других сертификатов подделывать не надо. Пусть в ходе лотереи выпало
число $i$. Тогда возможны 3 варианта:

\begin{ulist}
\item если для билета с номером $i$ сертификат был куплен, то победителем является
купивший его человек, и злоумышленник повлиять на это никак не может;
\item если для билета с номером $i$ сертификат был подделан, то победителем является
злоумышленник;
\item если не выполнено ни одно из перечисленных выше условий, то ближайшим билетом,
для которого есть сертификат, является подделанный билет (так как купленные 
сертификаты <<окружены>> подделанными) и победителем является злоумышленник. 
\end{ulist}

Таким образом, злоумышленник во всех трёх случаях либо оказывается единоличным
победителем, либо повлиять на выбор победителя не может. Оптимальная стратегия 
выбора сертификатов для подделывания доказана. Остаётся её реализовать.

Проще всего это сделать следующим образом. Будем хранить два последовательных номера
билетов, для которых были куплены сертификаты: <<предыдущий>> $pr$ и <<текущий>>
$cur$. Если номера являются соседними, т.е $pr + 1 = cur$, то подделки никакого
сертификата не требуется. В противном случае, необходимо подделать сертификат
для билета с номером $cur - 1$. Если, при этом, $pr + 1 \neq cur - 1$, то необходимо
в ответ добавить ещё билет с номером $pr + 1$. Таким алгоритмом будут найдены все
номера, для которых необходимо подделать сертификаты, лежащие между парами номеров с 
купленными сертификатами. Остаётся добавить номер на единицу меньше первого
купленного сертификата и номер на единицу больше последнего купленного сертификата,
если они не выходят за границу купленных номеров.

Остаётся полученные номера отсортировать, либо изначально добавлять в ответ номера
в порядке возрастания, что делается элементарно.
\input{code.tex}  